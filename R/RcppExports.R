# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

brentMinCPP <- function(f, interval = numeric(), lower = NA_real_, upper = NA_real_, tol = 1e-8, maxiter = 500L, trace = 0L) {
    .Call(`_smoothemplik_brentMinCPP`, f, interval, lower, upper, tol, maxiter, trace)
}

brentZeroCPP <- function(f, interval = numeric(), lower = NA_real_, upper = NA_real_, f_lower = NULL, f_upper = NULL, extendInt = "no", tol = 1e-8, maxiter = 500L, trace = 0L) {
    .Call(`_smoothemplik_brentZeroCPP`, f, interval, lower, upper, f_lower, f_upper, extendInt, tol, maxiter, trace)
}

#' @importFrom RcppParallel RcppParallelLibs
NULL

kernelFunCPP <- function(x, kernel, order, convolution = FALSE) {
    .Call(`_smoothemplik_kernelFunCPP`, x, kernel, order, convolution)
}

kernelWeightsOneCPP <- function(x, xout, bw, kernel = "gaussian", order = 2L, convolution = FALSE) {
    .Call(`_smoothemplik_kernelWeightsOneCPP`, x, xout, bw, kernel, order, convolution)
}

sparseKernelWeightsOneCPP <- function(x, xout, bw, kernel = "gaussian", order = 2L, convolution = FALSE) {
    .Call(`_smoothemplik_sparseKernelWeightsOneCPP`, x, xout, bw, kernel, order, convolution)
}

kernelWeightsCPP <- function(x, xout, bw, kernel = "gaussian", order = 2L, convolution = FALSE) {
    .Call(`_smoothemplik_kernelWeightsCPP`, x, xout, bw, kernel, order, convolution)
}

sparseKernelWeightsCPP <- function(x, xout, bw, kernel = "gaussian", order = 2L, convolution = FALSE) {
    .Call(`_smoothemplik_sparseKernelWeightsCPP`, x, xout, bw, kernel, order, convolution)
}

kernelDensityCPP <- function(x, xout, weights, bw, kernel = "gaussian", order = 2L, convolution = FALSE, chunks = 0L) {
    .Call(`_smoothemplik_kernelDensityCPP`, x, xout, weights, bw, kernel, order, convolution, chunks)
}

kernelSmoothCPP <- function(x, y, xout, weights, bw, kernel = "gaussian", order = 2L, LOO = FALSE, convolution = FALSE, chunks = 0L) {
    .Call(`_smoothemplik_kernelSmoothCPP`, x, y, xout, weights, bw, kernel, order, LOO, convolution, chunks)
}

tlogCPP <- function(x, a = as.numeric( c(1.0)), k = 4L, d = 0L) {
    .Call(`_smoothemplik_tlogCPP`, x, a, k, d)
}

weightedEuLCPP <- function(z, mu, ct, shift, n_orig, weight_tolerance, trunc_to = 0.0, SEL = TRUE, return_weights = FALSE, verbose = FALSE, chull_diag = FALSE) {
    .Call(`_smoothemplik_weightedEuLCPP`, z, mu, ct, shift, n_orig, weight_tolerance, trunc_to, SEL, return_weights, verbose, chull_diag)
}

