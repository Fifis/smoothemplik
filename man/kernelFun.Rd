% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothers.R
\name{kernelFun}
\alias{kernelFun}
\title{Basic univatiate kernel functions}
\usage{
kernelFun(
  x,
  kernel = c("gaussian", "uniform", "triangular", "epanechnikov", "quartic"),
  order = c(2, 4, 6),
  rescale = TRUE,
  convolution = FALSE
)
}
\arguments{
\item{x}{A numeric vector of values at which to compute the kernel function.}

\item{kernel}{Kernel type: uniform, Epanechnikov, triangular, quartic, or Gaussian.}

\item{order}{Kernel order. 2nd-order kernels are always non-negative. kth-order kernels have all moments from 1 to (k-1) equal to zero, which is achieved by having some negative values.}

\item{rescale}{Logical: rescale to unit variance? If \code{TRUE}, ensures that, for the chosen kernel
name, the second-order kernel integrates to 1:
\eqn{\int_{-\infty}^{+\infty} x^2 k(x) = \sigma^2_k = 1}.
This is useful because in this case, the constant \code{k_2} in formul√¶ 3.12 and 3.21
from \insertCite{silverman1986density;textual}{smoothemplik} is equal to 1.}

\item{convolution}{Logical: return the convolution kernel? (Useful for density cross-validation.)}
}
\value{
A numeric vector of the same length as input.
}
\description{
Computes 5 most
 popular kernel functions of orders 2, 4, and 6 with the potential of returning an analytical convolution kernel for density cross-validation.
}
\examples{
ks <- c("uniform", "triangular", "epanechnikov", "quartic", "gaussian"); names(ks) <- ks
os <- c(2, 4, 6); names(os) <- paste0("o", os)
cols <- c("#000000CC", "#0000CCCC", "#CC0000CC", "#00AA00CC", "#BB8800CC")
put.legend <- function() legend("topright", legend = ks, lty = 1, col = cols, bty = "n")
xgrid <- seq(-4, 4, length.out = 301)
plot(NULL, NULL, xlim = range(xgrid), ylim = c(0, 1.1),
  xlab = "", ylab = "", main = "Unscaled kernels", bty = "n"); put.legend()
for (i in 1:5) lines(xgrid, kernelFun(xgrid, kernel = ks[i], rescale = FALSE), col = cols[i])
par(mfrow = c(1, 2))
plot(NULL, NULL, xlim = range(xgrid), ylim = c(-0.1, 0.8), xlab = "", ylab = "",
  main = "4th-order scaled kernels", bty = "n"); put.legend()
for (i in 1:5) lines(xgrid, kernelFun(xgrid, kernel = ks[i], order = 4), col = cols[i])
plot(NULL, NULL, xlim = range(xgrid), ylim = c(-0.25, 1.2), xlab = "", ylab = "",
  main = "6th-order scaled kernels", bty = "n"); put.legend()
for (i in 1:5) lines(xgrid, kernelFun(xgrid, kernel = ks[i], order = 6), col = cols[i])
par(mfrow = c(1, 1))
plot(NULL, NULL, xlim = range(xgrid), ylim = c(-0.25, 1.4), xlab = "", ylab = "",
  main = "Convolution kernels", bty = "n"); put.legend()
for (i in 1:5) {
  for (j in 1:3) lines(xgrid, kernelFun(xgrid, kernel = ks[i], order = os[j],
  convolution = TRUE), col = cols[i], lty = j)
}; legend("topleft", c("2nd order", "4th order", "6th order"), lty = 1:3, bty = "n")

# All kernels integrate to correct values; we compute the moments
mom <- Vectorize(function(k, o, m, c) integrate(function(x) x^m * kernelFun(x, k, o,
  rescale = FALSE, convolution = c), lower = -Inf, upper = Inf)$value)
for (m in 0:6) {
  cat("\nComputing integrals of x^", m, " * f(x). \nSimple unscaled kernel:\n", sep = "")
  print(round(outer(os, ks, function(o, k) mom(k, o, m = m, c = FALSE)), 4))
  cat("Convolution kernel:\n")
  print(round(outer(os, ks, function(o, k) mom(k, o, m = m, c = TRUE)), 4))
}

}
\references{
\insertCite{silverman1986density}{smoothemplik}
}
