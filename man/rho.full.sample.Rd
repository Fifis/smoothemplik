% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simfunctions.R
\name{rho.full.sample}
\alias{rho.full.sample}
\title{Moment function for efficient full-sample estimation}
\usage{
rho.full.sample(
  theta,
  data,
  pi.hat = NULL,
  helper = c("gstar", "Ystar", "Dg", "DY", "mu"),
  helper.predicted = NULL,
  pi.bw = NULL,
  helper.bw = NULL,
  helper.degree = 0,
  PIT = TRUE
)
}
\arguments{
\item{theta}{A parameter vector at which the moment function is evaluated.}

\item{data}{A data frame on which the moment function is evaluated.}

\item{pi.hat}{A numeric vector contatining the predicted propensity score. Must be the same length as \code{nrow(data)}.}

\item{helper}{A string indicating which helper to use. See the vignette for a better explanation.}

\item{helper.predicted}{A numeric vector contatining the predicted helper value (notation from the paper). Must be the same length as \code{nrow(data)}.}

\item{pi.bw}{Smoothing bandwidth for propensity score estimation.}

\item{helper.bw}{Smoothing bandwidth(s) for propensity score estimation (the defult variable order is Z, X).}

\item{helper.degree}{Integer, passed to \code{kernelSmooth}.}

\item{PIT}{Logical: transform the values in \code{data} column-wise prior to smoothing?}
}
\value{
A numeric vector with moment function values.
}
\description{
Moment function for efficient full-sample estimation
}
\examples{
data <- generateData()
data.VS <- data[as.logical(data$D), ]
t0 <- c(1, 1) # True parameters
Ztheta <- t0[1] + t0[2] * data$Z
b.pi <- bw.CV(x = pit(data$X), y = data$D)
b.muY  <- bw.CV(x = apply(as.matrix(data.VS[, c("Z", "X"), ]), 2, pit), y = data.VS$Y)
b.mug <- bw.CV(x = apply(as.matrix(data.VS[, c("Z", "X"), ]), 2, pit), y = data.VS$U)
r.Ystar <- rho.full.sample(t0, data, helper = "Ystar", pi.bw = b.pi, helper.bw = b.muY)
r.DY    <- rho.full.sample(t0, data, helper = "DY"   , pi.bw = b.pi, helper.bw = b.muY)
r.gstar <- rho.full.sample(t0, data, helper = "gstar", pi.bw = b.pi, helper.bw = b.mug)
r.Dg    <- rho.full.sample(t0, data, helper = "Dg"   , pi.bw = b.pi, helper.bw = b.mug)

cols <- rainbow(4, end = 0.8, v = 0.6, alpha = 0.6)
plot(NULL, NULL, xlim = c(0, 1), ylim = c(-10, 10), bty = "n", xlab = "X", ylab = "rho")
points(data$X, r.Ystar, col = cols[1], pch = 16, cex = 0.75)
points(data$X, r.DY,    col = cols[2], pch = 16, cex = 0.75)
points(data$X, r.gstar, col = cols[3], pch = 16, cex = 0.75)
points(data$X, r.Dg,    col = cols[4], pch = 16, cex = 0.75)
plot(r.Ystar, r.gstar, bty = "n", col = data$D + 1)

# Smoothing linear functions with locally constant kernels is a bad idea
Zthetahat0 <- kernelSmooth(data.VS[, c("Z", "X")], Ztheta[as.logical(data$D)],
  xout = data[, c("Z", "X")], bw = c(0.5, 0.15), degree = 0)
Zthetahat1 <- kernelSmooth(data.VS[, c("Z", "X")], Ztheta[as.logical(data$D)],
  xout = data[, c("Z", "X")], bw = c(1.25, 0.25), degree = 1)
plot(data$Z, Zthetahat1, bty = "n")
points(data$Z, Zthetahat0, col = 2)
}
