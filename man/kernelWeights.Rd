% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/smoothers.R
\name{kernelWeights}
\alias{kernelWeights}
\title{Get kernel-based weights}
\usage{
kernelWeights(
  x,
  xgrid = NULL,
  bw = NULL,
  kernel = c("gaussian", "uniform", "triangular", "epanechnikov"),
  PIT = FALSE
)
}
\arguments{
\item{x}{A vector or a matrix of data points involved in weight computation.}

\item{xgrid}{A vector or a matrix of data points for which the weights of every observation in \code{x} are computed. If \code{NULL}, then
\code{x} itself is used as the grid.}

\item{bw}{Kernel bandwidth. Since it is the crucial parameter in many applications, throws a warning if not supplied, and then, Silverman's
rule of thumb (via \code{bw.row()}) is applied to every dimension of \code{x}.}

\item{kernel}{Character describing the desired kernel type (Gaussian is infinitely smooth but does not provide finite support).}

\item{PIT}{If TRUE, the Probability Integral Transform (PIT) is applied to all columns of \code{x} via \code{ecdf} in order to map all values
  into the [0, 1] range. May be an integer vector of indices of columns to which the PIT should be applied.

Note that if \code{pit = TRUE}, then the kernel-based weights become nearest-neighbour weights (i.e. not much different from the ones used
internally in the built-in \code{loess} function) since the distances now depend on the ordering of data, not the values per se.}
}
\value{
A matrix of weights of dimensions nrow(xgrid) x nrow(x).
}
\description{
Get kernel-based weights
}
